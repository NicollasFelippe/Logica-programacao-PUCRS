# -*- coding: utf-8 -*-
"""Logicafase2PUC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fxM7117sn9HReK20pw7TvzZKt6MTpHTp

#### 1.*texto em itálico* Carga e preparação de dados: trabalhar com arquivos de dados, realizando a sua leitura, filtragem das informações relevantes e armazenamento em estruturas de dados adequadas para consulta.
"""

import pandas as pd
import matplotlib.pyplot as plt

# Mapeamento das colunas
columns = ["data", "precip", "maxima", "minima", "horas_insol", "temp_media", "um_relativa", "vel_vento"]

# Ler os dados do CSV
df = pd.read_csv("Anexo_Arquivo_Dados_Projeto_Logica_e_programacao_de_computadores.csv", index_col="data", usecols=columns,  parse_dates=['data'], dayfirst=True)


# Plotar as 5 primeiras linhas
df.head()

"""A)  Visualização de intervalo de dados em modo texto: recebe dados inicio e fim e filtra 1) todos os dados, 2) apenas os de precipitação, 3) apenas os de temperatura, ou 4) apenas os de umidade e vento para o período informado

"""

def visualizacao(parm):
    #valida a visualização de dados para o intervalo desejado
    while parm not in [1, 2, 3, 4]:
        try:
            parm = int(input("Digite 1 para todos Dados, 2 para precipitacao, 3 para temperaturas, 4 para umidade e Vento: "))
        except ValueError:
            print("Você digitou um valor inválido. Tente novamente.")

    if parm == 1:
        return todosDados
    elif parm == 2:
        return precipitacao
    elif parm == 3:
        return temp
    elif parm == 4:
        return umidadeVento
#====================================================================================

def validar_entrada(data_str):
  #valida a entrada de dados mês e ano
  try:
    # Tenta criar um objeto pd.Timestamp
    data = pd.to_datetime('01/' + data_str, format='%d/%m/%Y')

    # Verifica se o DataFrame está vazio
    if df.empty:
        print("O DataFrame está vazio.")
        return False

    # Converte os extremos do índice para Timestamp
    min_date = pd.to_datetime(df.index.min())
    max_date = pd.to_datetime(df.index.max())

    # Verifica se a data está dentro do intervalo
    if (data < min_date) or (data > max_date):
        print("A data está fora do intervalo. Por favor tente uma data de 1961 a 07/2016")
        return False

    return True

  except ValueError:
    # Se ocorrer um ValueError, inválida a entrada
    print("A entrada é inválida.")
    return False

#=====================================================================================

#=====================================================================================
def plotar_grafico1():
  #plotagem de dados para deixar mais interessante a experiência ao escolher a opção 1
  intervalo_dias = 10

  dados_para_exibir = dados_filtrados.iloc[::intervalo_dias]

        # Plotagem do gráfico de barras
  ax = dados_para_exibir[["maxima", "minima", "horas_insol", "temp_media", "um_relativa", "vel_vento"]].plot(kind='bar')
  ax.legend(["Temp.maxima", "Temp.minima", "horas insol", "temp. media", "um.relativa", "vel.vento"])
  plt.xlabel('Data')
  plt.ylabel('todas as informações')
  plt.title('Gráfico para Todas as informações no período filtrado com intervalo de 10 dias')

  plt.show()

#=======================================================================================================
def plotar_grafico2():
  #plotagem de dados para deixar mais interessante a experiência ao escolher a opção 2
  intervalo_dias = 10

  dados_para_exibir = dados_filtrados.iloc[::intervalo_dias]

        # Plotagem do gráfico de barras
  ax = dados_para_exibir['precip'].plot(kind='bar')
  ax.legend(["Precipiração"])
  plt.xlabel('Data')
  plt.ylabel('precipitação')
  plt.title('Gráfico para Precipitação no período filtrado com intervalo de 10 dias')

  plt.show()
#==========================================================================================================
def plotar_grafico3():
  #plotagem de dados para deixar mais interessante a experiência ao escolher a opção 3
  intervalo_dias = 10

  dados_para_exibir = dados_filtrados.iloc[::intervalo_dias]

        # Plotagem do gráfico de barras
  ax = dados_para_exibir[["maxima", "minima", "temp_media"]].plot(kind='bar')
  ax.legend(["Temp. Máxima", "Temp. Mínima", "Temp. Média"])
  plt.xlabel('Data')
  plt.ylabel('Temperatura',)
  plt.title('Gráfico para Temperaturas no período filtrado com intervalo de 10 dias')

  plt.show()
#===========================================================================================================
def plotar_grafico4():
  #plotagem de dados para deixar mais interessante a experiência ao escolher a opção 4
  intervalo_dias = 10

  dados_para_exibir = dados_filtrados.iloc[::intervalo_dias]

        # Plotagem do gráfico de barras
  ax = dados_para_exibir[['um_relativa', 'vel_vento']].plot(kind='bar')
  ax.legend(["Umidade Relativa", "Velocidade do vento"])
  plt.xlabel('Data')
  plt.ylabel('um_relativa',)
  plt.title('Gráfico para Umidade Relativa e Velocidade do vento no período filtrado com intervalo de 10 dias')

  plt.show()

#===================================================
def valida_mes(um_mes):
  #valida o mês correto no intervalo de 1
    while um_mes not in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]:
      try:
          um_mes = int(um_mes)
          if um_mes not in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]:
              raise ValueError  # Lança uma exceção se o valor não estiver no intervalo correto
      except ValueError:
          um_mes = input("Você digitou um valor inválido. Por favor, digite um mês de 1 a 12: ")

    return int(um_mes)

todosDados = df[["maxima", "minima", "horas_insol", "temp_media", "um_relativa", "vel_vento"]]
precipitacao = df[["precip"]]
temp = df[["maxima", "minima", "temp_media"]]
umidadeVento = df[["um_relativa", "vel_vento"]]


# Solicite as datas de início e fim do usuário no formato mm/yyyy
#Loop para obrigar o usuário a digitar certo
while True:
    inicio = input("Digite a data de início (formato mm/yyyy): ")
    if validar_entrada(inicio):
        break
    else:
        print("Data de início inválida. Tente novamente.")
# Loop para obrigar o usuário a digitar certo
while True:
    fim = input("Digite a data de fim (formato mm/yyyy): ")
    if validar_entrada(fim):
        break
    else:
        print("Data de fim inválida. Tente novamente.")

# Converta as datas de entrada para o formato de string com o último dia do mês
inicio = pd.to_datetime('01/' + inicio, format='%d/%m/%Y').strftime('%Y-%m-%d')
fim = pd.to_datetime(fim, format='%m/%Y') + pd.offsets.MonthEnd(0)
fim = fim.strftime('%Y-%m-%d')

# Crie uma máscara booleana para o intervalo desejado
mask = (df.index >= inicio) & (df.index <= fim)

# Solicite ao usuário a variável que deseja visualizar
variavel_desejada = visualizacao(int(input("Digite para visualizar\n 1) todos os dados\n 2) apenas os de precipitação\n 3)apenas os de temperatura\n 4) apenas os de umidade e vento ")))

# Selecione a variável desejada e os dados filtrados usando a máscara
dados_filtrados = df.loc[mask, variavel_desejada.columns]

# Imprima os dados filtrados
print(dados_filtrados)

if not dados_filtrados.empty:
    if variavel_desejada.equals(todosDados):
        plotar_grafico1()
    elif variavel_desejada.equals(precipitacao):
        plotar_grafico2()
    elif variavel_desejada.equals(temp):
        plotar_grafico3()
    elif variavel_desejada.equals(umidadeVento):
        plotar_grafico4()
else:
    print("DataFrame vazio. Nada a plotar.")

"""#### 3 b)

Mês menos chuvoso: o mês/ano com menor precipitação, considerando todos os dados do arquivo. Exiba também a menor precipitação na tela.
Utilize obrigatoriamente um dicionário e implemente ao menos uma função.  Lembre-se de considerar todos os dados do arquivo!
"""

import calendar

# Mapeamento dos meses em inglês para português
meses_ingles_para_portugues = {
    'January': 'Janeiro',
    'February': 'Fevereiro',
    'March': 'Março',
    'April': 'Abril',
    'May': 'Maio',
    'June': 'Junho',
    'July': 'Julho',
    'August': 'Agosto',
    'September': 'Setembro',
    'October': 'Outubro',
    'November': 'Novembro',
    'December': 'Dezembro'
}

# Transforma numeral para mês por extenso
def numeral_para_mes_extenso(numero_mes):
    # Verifica se o número do mês está dentro do intervalo válido (1 a 12)
    if numero_mes < 1 or numero_mes > 12:
        return "Mês inválido"

    # Obtém o nome do mês a partir do número
    nome_mes = calendar.month_name[numero_mes]

    return meses_ingles_para_portugues.get(nome_mes, "Mês inválido")

# Calcula o mês menos chuvoso
def getMesMenosChuvoso():
    # Cria um dicionário para armazenar a soma da precipitação por mês/ano
    precipitacao_por_mes_ano = {}

    # Itera sobre os dados do DataFrame para calcular a soma da precipitação por mês
    for index, row in df.iterrows():
        mes_ano = index.strftime('%m/%Y')  # Obtém o mês/ano no formato 'MM/YYYY'
        precipitacao = row['precip']

        if mes_ano in precipitacao_por_mes_ano:
            precipitacao_por_mes_ano[mes_ano] += precipitacao
        else:
            precipitacao_por_mes_ano[mes_ano] = precipitacao

    # Encontra o mês/ano com a menor precipitação
    mes_menos_chuvoso = min(precipitacao_por_mes_ano, key=precipitacao_por_mes_ano.get)
    menor_precipitacao = round(precipitacao_por_mes_ano[mes_menos_chuvoso], 2) # Arredonda para duas casas decimais

    return mes_menos_chuvoso, menor_precipitacao

mes_menos_chuvoso, menor_precipitacao = getMesMenosChuvoso()

# Extrai o número do mês de mes_menos_chuvoso
numero_mes_menos_chuvoso = int(mes_menos_chuvoso[:2])

print(f'O mês menos chuvoso é {numeral_para_mes_extenso(numero_mes_menos_chuvoso)}, com uma precipitação igual a {menor_precipitacao} mm.')

"""#### 3 b) Média da temperatura mínima de um determinado mês (auge do inverno) nos últimos 11 anos (2006 a 2016):"""

# Solicita ao usuário o mês até que seja fornecido um valor válido
mes_frio = valida_mes(input("Informe o mês que você quer ver a média da temperatura mínima de 2006 a 2016: "))

def getMediaTempMinimaDoMes(mes_desejado):

    # Converter o índice para o formate datetime
    df.index = pd.to_datetime(df.index)

    # Filtrar os anos indicados no dataset
    df_periodo_desejado = df[(df.index.year >= 2006) & (df.index.year <= 2016)]

    # Filtra o dataframe para o mês desejado
    df_mes_desejado = df_periodo_desejado[df_periodo_desejado.index.month == mes_desejado]

    # Calcula a média da temperatura mínima para o mês escolhido
    media_temp_minima = round(df_mes_desejado['minima'].mean(), 2)

    return media_temp_minima

media_temp_minima = getMediaTempMinimaDoMes(mes_frio)

print(f'A media da temperatura minima para o mês é: {media_temp_minima}')

def getMediaTempMinimaDoMes(ano, mes, df):
    # Converter o índice para o formato datetime
    df.index = pd.to_datetime(df.index)

    # Filtrar o ano indicado no DataFrame
    df_ano = df[df.index.year == ano]

    # Filtra o DataFrame para o mês desejado
    df_mes = df_ano[df_ano.index.month == mes]

    # Calcula a média da temperatura mínima para o mês escolhido
    media_temp_minima = round(df_mes['minima'].mean(), 2)

    return media_temp_minima

# Função para calcular as médias por ano
def calcularMediasPorAno(mes, df):
  resultadosMedia = []
    # Inicializa um dicionário para armazenar as médias por ano
  medias_por_ano = {}
  # Loop de 2006 a 2016
  for ano in range(2006, 2017):
        # Calcula a média da temperatura mínima para o mês escolhido no ano atual
    media_temp_minima = getMediaTempMinimaDoMes(ano, mes, df)

        # Armazena a média no dicionário
    medias_por_ano[f"{mes:02d}/{ano}"] = media_temp_minima

  return medias_por_ano

# Calcula as médias por ano
resultados = calcularMediasPorAno(mes_frio, df)

# Exibe os resultados
resultadosMedia = []
for chave, valor in resultados.items():
  print(f"{chave} = {valor}")

  resultadosMedia.append(valor)

print(f"Aqui você vê a média geral da temperatura mínima do mês escolhido no intervalo de 2006 a 2016 = {sum(resultadosMedia) / 11:.2f}")



plt.bar(resultados.keys(), resultados.values())
plt.xlabel('Datas')
plt.ylabel("temperaturas")
plt.title(f"médias de temperatura mínima do mês {mes_frio} nos últimos 11 anos")
plt.xticks(rotation=45)
plt.show()